Контрольные вопросы. Раздел 4. Lambda, StreamAPI, FP

1. Что такое функциональные интерфейсы?

2. Перечислите функциональные интерфейсы из пакета java.util.function.

3. Что такое функции высшего порядка?

4. Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка?

5. Что такое ссылки на методы?

6. Что такое ссылки на конструкции?

7. Расскажите о зоне видимости переменных в lamdba - выражениях?

8. Как быть в ситуации, если внутри lamdba - выражении операторы могут выкинуть исключение?

Хорошая статья по стримам:
https://javarush.ru/groups/posts/2203-stream-api

9. Что такое Stream API?
9.1 Задача Stream API - упростить работу с наборами данных, в частности, упростить операции фильтрации, сортировки
и другие манипуляции с данными. Вся основная функциональность данного API сосредоточена в пакете java.util.stream.
9.2 Stream API — это новый способ работать со структурами данных в функциональном стиле. Stream (поток) API (описание
способов, которыми одна компьютерная программа может взаимодействовать с другой программой) — это по своей сути поток данных.
9.3 Важные моменты:
- Обработка не начнётся до тех пор, пока не будет вызван терминальный оператор. list.stream().filter(s -> s > 5) (не возьмёт ни единого элемента из списка);
- Экземпляр, стрима нельзя использовать более одного раза =( ;

10. Расскажите, какой шаблон проектирования используется внутри Stream API?

11. Что делает метод filter?
filter(Predicate predicate) фильтрует стрим, пропуская только те элементы, что проходят по условию
(Predicate встроенный функциональный интерфейс, добавленный в Java SE 8 в пакет java.util.function.
Проверяет значение на “true” и “false”);

12. Что делает метод map?
map(Function mapper) даёт возможность создать функию с помощью которой мы будем изменять каждый элемент и пропускать
его дальше (Функциональный интерфейс Function<T,R> представляет функцию перехода от объекта типа T к объекту типа R)

13. Что делает метод flatMap?
flatMap(Function<T, Stream<R>> mapper) — как и в случае с map, служат для преобразования в примитивный стрим.

14. Что делает метод collect?
- toList() — собирает элементы в List.
List<Integer> list = Stream.of(99, 2, 3).collect(Collectors.toList());
- toSet() — cобирает элементы в множество:
Set<Integer> set = Stream.of(99, 2, 3).collect(Collectors.toSet());
- counting() — Подсчитывает количество элементов:
Long count = Stream.of("1", "2", "3", "4").collect(Collectors.counting());

String a = Stream.of("s", "u" ,"p", "e", "r").collect(Collectors.joining());
System.out.println(a); // super

String b = Stream.of("s", "u", "p", "e", "r").collect(Collectors.joining("-"));
System.out.println(b); // s-u-p-e-r

String c = Stream.of("s", "u", "p", "e", "r").collect(Collectors.joining(" -> ", "[ ", " ]"));
System.out.println(c);  // [ s -> u -> p -> e -> r ]

15. Что делает метод reduce?
reduce(T identity, BinaryOperator accumulator) — преобразовывает все элементы стрима в один объект(посчитать сумму всех элементов, либо найти минимальный элемент), cперва берётся объект identity и первый элемент стрима, применяется функция accumulator и identity становится её результатом. Затем всё продолжается для остальных элементов.
int sum = Stream.of(1, 2, 3, 4, 5).reduce(10, (acc, x) -> acc + x);// = 25
reduce(BinaryOperator accumulator) — такой же метод как и выше но отсутсвует начальный identity, им служит первый элемент стрима

16. Что делает метод findFirst?
findFirst() – вытаскивает первый элемент стрима.
Stream.of(1, 2, 3, 4, 9).findFirst();

17. Возможно ли прервать выполнение потока по аналогии с break?

18. Возможно ли пропустить элемент потока по аналогии с continue?

19. Что такое Optional?

20. Перечислите методы Optional?

21. Расскажите про фабричные методы List.of, Set.of, Map.of?

22. Для чего используется ключевое слово var?

23. В каких случаях можно использовать var?