Контрольные вопросы часть 2. ООП.

1. Что такое ООП?

2. Базовые концепции ООП?
2.1 Инкапсуляция - механизм, который связывает код и данные которыми он манипулирует, сохраняя их в безопасности,
    как от внешнего так и от ошибочного внутреннего использования.
2.2 Наследование - процесс, когда один объект получает св-ва другого.
2.3 Полиморфизм - принцип ООП, который позволяет использовать один и тот же объект для общего класса действий (много форм).

3. Укажите из каких элементов состоит класс.
Класс состоит из следующих элементов:
Поля - параметры, которыми манипулирует класс.
Конструктор - то, что создает объекты данного класса.
Методы - действия, которые производит класс.

4. Что такое конструктор? Типы конструкторов?
4.1 Конструктор - это специальный метод, который вызывается при создании нового объекта.
    Конструктор инициализирует объект непосредственно во время создания.
    Имя конструктора совпадает с именем класса, включая регистр, а по синтаксису конструктор похож на метод без возвращаемого значения.

class Box {
    //1. Поля
    int width; // ширина коробки
    int height; // высота коробки
    int depth; // глубина коробки

    //2. Конструктор
    Box() {
        width = 10;
        height = 10;
        depth = 10;
    }

    //3. Методы
    //3.1 Вычисление объёма коробки
    int getVolume() {
    	return width * height * depth;
    }
}
4.2 В Java есть три типа конструктора:
    1) Конструктор без аргументов (по-умолчанию).
       Если мы не определяем конструктор в класса, то компилятор создает конструктор по-умолчанию для класса.
       И если мы пишем свой конструктор с аргументами или без аргументов, то компилятор не создает конструктор по-умолчанию.
       Конструктор по-умолчанию задает нулевые значения полей объекта класса в зависимости от типа при создании объекта.
    2.1) Параметризованный конструктор.
        Box(int w, int h, int d) {
            this.width = w;
            this.height = h;
            this.depth = d;
        }
    2.2) Параметризованный конструктор с обобщением типов.
        class GenConstructor
        {
         private double val;

         <T extends Number> GenConstructor(T arg)
         {
            val = arg.doubleValue();
         }

         void printValue()
         {
            System.out.println("val: "+val);
         }
        }

        class GenConstructorDemo
        {
         public static void main(String args[])
         {
            GenConstructor gc1 = new GenConstructor(100);
            GenConstructor gc2 = new GenConstructor(123.5F);

            gc1.printValue();
            gc2.printValue();
         }
        }
    3) Параметризированные конструкторы с аргументами переменной длины.
       Параметр, содержащий переменное число аргументов должен обязательно быть последним в списке параметров.
        class Checking
        {
            public Checking(String s, int ... n)
            {
            }
        }
4.3 Характеристики конструктора:
    - Имя конструктора должно совпадать с именем класса;
    - Конструктор имеется в любом классе. Даже если вы его не написали, компилятор Java сам создаст конструктор по умолчанию (default constructor),
      который будет пустым и не делает ничего, кроме вызова конструктора суперкласса Object;
    - Конструкторов может быть несколько в классе. В этом случае конструкторы называют перегруженными;
    - Конструктор не имеет возвращаемого типа, им не может быть даже тип void, если возвращается тип void, то это уже не конструктор а метод, несмотря на совпадение с именем класса.
    - В конструкторе допускается применение модификаторов доступа, можно задать один из модификаторов: public, protected, private или без модификатора.
    - Конструктор не может иметь модификаторов abstract, final, native, static или synchronized;
    - Ключевое слово this cсылается на другой конструктор в этом же классе. Если используется, то обращение должно к нему быть первой строкой конструктора;
    - Ключевое слово super вызывает конструктор родительского класса. Если используется, должно обращение к нему быть первой строкой конструктора;
    - Если в классе определен параметризированный конструктор, то вызов конструктора по-умолчанию приведет к ошибке.
4.4 Передача параметров в конструктор:
    1. В языках программирования существует в основном два вида параметров:
    - основные типы (примитивы);
    - ссылки на объекты.
    Термин вызов по значению (call by value) означает, что  конструктор получает значение, переданное ему вызывающим модулем.
    В противоположность этому, вызов по ссылке (call by reference) означает, что конструктор получает от вызывающего модуля адрес переменной.
    2. В языке Java используется только вызов по значению. По значению параметра и по значению ссылки параметра.
    Java не использует вызов по ссылке для объектов (хотя многие программисты и авторы некоторых книг это утверждают).
    Параметры при передаче объектов в Java осуществляются не по ссылке, а по значению ссылки на объекты !
    В любом случае конструктор получает копии значений всех параметров.
    3. Конструктор не может делать со своими входными параметрами:
    - конструктор не может менять значения входных параметров основных (примитивных) типов;
    - конструктор не может изменять ссылки входных параметров;
    - конструктор не может переназначать ссылки входных параметров на новые объекты.
    4. Конструктор МОЖЕТ делать со своими входными параметрами:
    - изменять состояние объекта, передаваемого в качестве входного параметра.

5. Можно ли наследовать конструктор?
   Конструктор родительского класса не наследуется в дочернем классе,
   и поэтому super () автоматически добавляется в конструктор дочернего класса, если нет явного вызова super или this.

6. Что такое перегрузка конструктора?
    6.1 Перегрузка конструктора - когда внутри одного класса определяются 2 или более конструктора с одним и тем же именем,
        но они различаются по кол-ву параметров в аргументе.
    6.2 Перегрузка конструкторов - когда онструкторы одного класса могут иметь одинаковое имя и различную сигнатуру (аргументы).
        Сигнатура конструктора – это количество и типы параметров, а также последовательность их типов в списке параметров конструктора.
    6.3 Пример кода:
        Box() {}; //конструктор по-умолчанию
        Box(int w, int h, int d) { //параметризированный конструктор
            this.width = w;
            this.height = h;
            this.depth = d;
        }
        Box(int cube) { //перегрузка параметризированного конструктора
            this.width = cube;
            this.height = cube;
            this.depth = cube;
        }

7. Что такое статический метод?
7.1 Статические методы — это методы в Java, которые можно вызывать без создания объекта класса.
    Статическое ключевое слово может использоваться с классом, переменной, методом и блоком.
    Статические члены принадлежат классу, а не конкретному экземпляру, это означает, что если вы сделаете член статическим,
    вы сможете получить к нему доступ без объекта.
    Статические члены являются общими для всех экземпляров (объектов) класса, но нестатические члены являются отдельными для каждого экземпляра класса.
7.2 Интересные моменты:
    1) Доступ к членам и методам:
       В статическом методе метод может получить доступ только к статическим членам данных и статическим методам другого класса или того же класса,
       но не может получить доступ к нестатическим методам и переменным. Также статический метод может переписать значения любого статического члена данных.
    2) Процесс вызова:
       В статическом методе память статического метода фиксируется в оперативной памяти, по этой причине нам не нужен объект класса,
       в котором статический метод определен для вызова статического метода. Для вызова метода нам нужно написать имя метода, а затем имя класса:
       Config.init();
    3)Выделение памяти:
       В статическом методе распределение памяти происходит только один раз, потому что ключевое слово static фиксировало определенную память
       для этого метода в ram. Поэтому, когда метод вызывается каждый раз в программе, каждый раз, когда используется определенная память.
       По этой причине выделяется меньше памяти.
7.3 Важные моменты:
    - Они предназначены для совместного использования всеми объектами, созданными из одного класса.
    - Статические методы не могут быть переопределены.
    - Не могут напрямую обращаться к методам экземпляра и переменным экземпляра.


8. Что такое не статический метод?
8.1 Не статический метод - метод без ключевого слова static перед именем метода.
8.2 Интересные моменты:
    1) Доступ к членам и методам:
       В нестатическом методе метод может получить доступ к статическим членам данных и статическим методам,
       а также к нестатическим членам и методу другого класса или того же класса, а также может изменить значения любого статического члена данных.
    2) Процесс вызова:
       В нестатическом методе память нестатического метода не фиксирована в оперативной памяти, поэтому нам нужен объект класса для вызова
       нестатического метода. Для вызова метода нам нужно написать имя метода, а затем имя объекта класса.
       Config config = new Config();
       config.init();
    3) Выделение памяти:
       В нестатическом методе здесь выделение памяти происходит, когда метод вызывается и память выделяется каждый раз, когда вызывается метод.
       Так много памяти используется здесь.

9. Для чего используется ключевое слово this?
   Ключевое слово this используется в двух случаях:
9.1 Когда одинаковые имена у поля класса и переменной метода/конструктора;
9.2 Когда нужно вызвать конструктор одного типа (например, конструктор по умолчанию или параметризированный) из другого.
Это еще называется явным вызовом конструктора.
9.3 Пример кода для 9.1, 9.2:
class Human{
    int age;
    int weight;
    int height;

    Human(int age, int weight){
        this.age = age;       //9.1
        this.weight = weight; //9.1
    }

    Human(int age, int weight, int height){
        //вы вызываете конструктор с двумя параметрами
        this(age, weight); //9.2
        //и добавляете недостающую переменную
        this.height = height;
    }
}

10. Какой класс является базовый родительным классов для всех классов?
Все классы исходят от суперкласса Object

11. Что такое наследование? Приведите примеры из реальной жизни.
    Наследование - это когда один объект получает свойства другого, добавляя их к своим.
    К примеру есть класс Car("Машина"), которая является родителем для классов: седан, универсал и малолитражный хэтч-бэк.
    Иили есть класс Fiqure("Фигура") и у нее могут быть потомки: квадрат, треугольник, шестриугольник и тд.

12. Опишите процесс создания нового объекта.
12.1 Создание объектов в java проходит через 2 этапа:
     1 этап: Объявляем переменную с типом класса Box
     Box myBox; //объявляем ссылку на объект
     2 Этап: Получение конкретной, физической копии объекта
     myBox = new Box(); //выделяет память под объект Box и возвращает ссылку на адрес памяти
12.2 Оператор new резервирует память под объект и возвращает ссылку на него.
     Эта ссылка представляет собой адрес объекта в памяти, зарезервированной оператором new.
     Затем эта ссылка сохраняется в переменной.
     В результате переменная myBox содержит адрес памяти конкретного объекта типа Box.

13. Как вызвать метод из родительского класса?
    Ключевое слово super можно использовать для вызова конструктора суперкласса и для обращения к члену суперкласса, скрытому членом подкласса

14. Что такое переопределение метода?
14.1 Переопределение это - когда подкласс обеспечивает свою реализацию метода, чем в суперклассе.
14.2 Пример кода:
public class Bear extends Animal {
    public void voice() { р-р-р-р;}
}

public class Cat extends Animal {
    public void voice() { мяу!;}
}

15. Можно ли переопределить статический метод?

16. Что такое виртуальная функция и используются ли они в Java?

17. Что такое перегрузка метода?
17.1 Перегрузка - когда внутри одного класса определяются 2 или более методов с одним и тем же именем,
но они различаются по типу и/или кол-ву параметров.
17.2 Пример кода 1:
void Test();
void Test(int a);
void Test(double b, int c);
17.3 Пример кода 2:
Если бы в Java отсутствовала перегрузка методов (как в Си), то необходимо было бы писать свои функции под каждый тип переменных: abs, labs, fabs.

18. Можно ли изменить тип возвращаемых тип данных при перегрузке метода?

19. Что такое множественное наследование? Как его можно реализовать в Java.

20. Что такое полиморфизм? Приведите примеры из реальной жизни.

21. Что такое инкапсуляция?
21.1 Инкапсуляция - механизм, который связывает код и данные, которыми он манипулирует сохраняя их в безопасности,
     как от внешнего влияния (использования), так и от внешнего влияния (использования), так и от ошибочного (внутреннего)
     использования.
21.2 Инкапсуляция - защитная оболочка которая предохраняет код и данные от произвольного доступа от других кодов, определенных
     вне этой оболочки.
21.3 Пример инкапсуляции 1:
     Инкапсулированно:
     - двигатель
     - проводка
     - электронные устройства
     - бак, топливная система
     Выставлено наружу:
     - педали
     - руль
     - ручка, переключатель скоростей
     - ключ зажигания
     - кнопки на приборной доске
21.4 Пример инкапсуляции 2:
     Инкапсулированно:
     - электрические платы
     - кинескоп
     - трансформаторы
     Выставлено наружу:
     - кнопки
     - разъемы для подключения внешних устройств
     - пульт управления

22. Как реализована инкапсуляция в Java?
22.1 Как применяется инкапсуляция
     Есть несколько способов регулировать доступ к нашим данным. Основные это:
     - Модификаторы доступа (Access modifiers),
     - Геттеры и Сеттеры (Getters and Setters).
22.2 Преимущества инкапсуляции:
     - Поля класса можно сделать только для чтения или только для записи.
     - Класс может иметь полный контроль над тем, что хранится в его полях.
     - Если элемент данных объявлен как «закрытый», доступ к нему возможен
       только в пределах одного класса. Никакой внешний класс не может получить доступ к элементу данных (переменной) другого класса.
     - мы храним переменную и методы в одном месте. Это место «класс». Класс является основой для инкапсуляции.

23. Что такое абстракция?
23.1 Абстракция – это процесс скрытия деталей реализации от пользователя, предоставляя ему только функционал.
     Иными словами, пользователь будет владеть информацией о том, что объект делает, а не как он это делает.
23.2 Абстракция является основой объектно-ориентированного программирования и позволяет работать с объектами, не вдаваясь в особенности их реализации.

24. Как реализована абстракция в Java?
24.1 В Java абстракция достигается с использованием абстрактных классов и интерфейсов:
     Абстрактный класс - это класс, у которого не реализован один или больше методов.
     Абстрактный класс содержит в себе ключевое слово abstract, известен как абстрактный класс.
     - Абстрактные классы в Java могут содержать или не содержать абстрактные методы, т.е. методы без тела (public void get();)
     - Если класс имеет хотя бы один абстрактный метод, то класс должен быть объявлен абстрактным.
     - Если класс объявлен абстрактным, его нельзя реализовать.
     - Чтобы использовать абстрактный класс, вам нужно наследовать его из другого класса, обеспечить реализацию абстрактных методов в нём.
     - Если вы наследуете абстрактный класс в Java, вам нужно обеспечить реализацию всех абстрактных методов в нём.
24.2 Абстрактный метод.
     Если вы хотите, чтобы класс содержал конкретный метод, но вы желаете, чтобы фактическая реализация этого метода определялась дочерними классами,
     вы можете объявить метод в родительском классе как абстрактный.
     Ключевое слово abstract используется для объявления метода абстрактным.
     Вам нужно разместить ключевое слово abstract перед именем метода во время его объявления.
     Абстрактный метод в Java содержит сигнатуру метода, но не содержит тела метода.
     Вместо фигурных скобок у абстрактного метода будет точка с запятой (;) на конце.
24.3 Интерфейс — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет переменных класса.
24.4 Разница между абстрактными классами и интерфейсами?
     1) Интерфейс описывает только поведение. У него нет состояния. А у абстрактного класса состояние есть: он описывает и то, и другое.
     2) Абстрактный класс связывает между собой и объединяет классы, имеющие очень близкую связь.
        В то же время, один и тот же интерфейс могут реализовать классы, у которых вообще нет ничего общего.
     3) Классы могут реализовывать сколько угодно интерфейсов, но наследоваться можно только от одного класса.
24.5 Interface vs Abstract class?
      == Interface ==
     1) Interface support multimple implementations.
     2) Interface does not contain Data Member
     3) Interface does not contain Constructors
     4) An interface contains only incomplete member (signature of member)
     5) An interface cannot have access modifiers by default everything is assumed as public
     6) Member of interface can not be Static

      == Abstract Class ==
     1) Abstract Class does not support multiple inheritance
     2) Abstract Class contains Data Member
     3) Abstract Class contains Constructor
     4) An Abstract Class Contains both incomplete (abstact) and complete member
     5) An Abstract Class can contains access modifiers for the sub, functions, properties
     6) Only Complete Member of abstact class can be Static

25. Что такое интерфейс?
25.1 В языке Java подобную проблему частично позволяют решить интерфейсы.
     Интерфейсы определяют некоторый функционал, не имеющий конкретной реализации, который затем реализуют классы, применяющие эти интерфейсы.
     И один класс может применить множество интерфейсов.
     Чтобы определить интерфейс, используется ключевое слово interface. Например:

26. Что такое внутренний класс? Типы внутренних классов.

--27. Что такое анонимный класс.
27.2 Статья
https://javarush.ru/groups/posts/1553-urovenjh-24-otvetih-na-voprosih-k-sobesedovaniju-po-teme-urovnja

28. Для чего используется конструктор в абстрактном классе?
28.1 В абстрактном классе могут быть неабстрактные свойства, поля и методы.
     Для инициализации свойств и полей - кокраз таки и используется конструктор.
28.2 Чтобы в каждом конструкторе наследника не писать одно и то же.
28.3 Статья (10 вопросов по абстрактным классам и интерфейсам с собеседований по Java)
https://javarush.ru/groups/posts/431-10-voprosov-po-abstraktnihm-klassam-i-interfeysam-s-sobesedovaniy-po-jazihku-java

--29.Можно ли создать анонимный класс. если в классе нет конструктора по умолчанию?
29.1 У всех классов всегда есть конструктор.
     Если вы не определяете его явно, компилятор сделает это за вас. В том числе для анонимных классов.

30.Что такое композиция?

31.Что такое агрегация?

32. Какие типы исключительных ситуаций бывают?
32.1 Все исключения делятся на 2 вида: -> checked (проверяемые),
                                       -> unchecked (непроверяемые).
32.2 Checked (проверяемые) исключения происходят от Exception. Компилятор java знает о самых
     распространенных исключениях и знает, в каких ситуациях они могут возникнуть. Например, когда
     программист считывает данные из файла, может возникнуть, что файла не существует. Поэтому
     компилятор заранее проверяет наш код на наличие потенциальных исключений. Если он их найдет, то не скомпилирует
     код, пока мы их не обработаем.
     К Checked относятся: IOException, FileNotFound, SQLException.
32.3 Unchecked (непроверяемые) исключения происходят от класса Runtime exception. Этих ошибок компилятор не ожидает.
     Люди сами создают эти ошибки своими руками, поэтому компилятор не будет проверять обработку таких исключений в коде.
     К Unchecked относятся: ArithmeticException (при делении на 0), ArrayIndexOfBoundsException (при выходе индекса за диапазон).
32.4 Checked exception - they MUST BE handled by using try-catch or using by throws clause on methods. (-> Exception)
     Unchecked exception - can OPTIONALLY BE handled, the same way checked exception are handled. (-> Runtime Exception)
32.5 Ситуации при которых восстановление нормальной работы программы невозможно -> unchecked (это Error + RuntimeException).
     К первой группе относятся ситуации, унаследованные из класса Error. Это ошибки, возникающие в программе в результате сбоя работы JVM,
     переполнения памяти, сбоя системы. Такой тип исключений является неконтролируемыми (unchecked) на стадии компиляции.
     Поэтому их обработка не является обязательной.

     Ко второй группе относятся исключения, предвидимые компилятором на стадии написания программы, для которых должен быть написан код обработки.
     Разработчик должен их оборабатывать. Проверка checked исключения происходит в момент компиляции.
     Восстановление возможно -> checked
32.6 Throwable — родительский класс в иерархии Java исключений.
     Он имеет два дочерних объекта — Error и Exception.
     Исключения далее разделены на проверяемые исключения и исключения времени выполнения.
32.7 Иерархия исключений:
                  Object
                    |
                 Thowable
               / (checked) \
              /             \
             /            Error ------ IOError
            /          (unchecked) --- OutOfMemory
       Exception
          |     \
          |      \
          |     Runtime exception --+-- NPE (NullPointerException)
          |       (unchecked)       +-- ArithmeticException
          |                         +-- IndexOfBoundException
      (checked)
     IOException,
     SQLException,
     FileNotFound
      Exception
32.8 Статья:
https://javadevblog.com/polnoe-rukovodstvo-po-obrabotke-isklyuchenij-v-java.html

33. Как обрабатываются исключительные ситуации?
33.1 try - определяет блок кода, в котором может произойти исключение. catch - определяет блок кода, в котором происходит обработка исключений,
     finally - блок кода (необязательный), но при его наличии, выполняется в любом случае, независимо от результатов выполнения.
     Блок try-catch используется для обработки исключений в коде. Слово try — это начало блока обработки, catch — конец блока для обработки исключений.
     Мы можем использовать сразу несколько блоков catch при одном try. catch в качестве параметра принимает тип исключения для обработки.
33.2 finally — необязательная завершающая конструкция блока try-catch. Как только исключение остановило процесс исполнения программы, в finally мы можем
     безопасно освободить какие-то открытые ресурсы. Следует отметить, что finally блок выполняется всегда — не смотря на появление исключительной ситуации.
33.3 throws — когда мы бросаем исключение в методе и не обрабатываем его, то мы должны использовать ключевое слово throws в сигнатуре метода для того,
     чтобы пробросить исключение для обработки в другом методе. Вызывающий метод может обработать это исключение или пробросить его еще дальше с помощью throws в сигнатуре метода.
     Следует отметить, что пробрасывать можно сразу несколько исключений.
     throws - используется в сигнатуре для предупреждения, о том, что метод может выбросить исключение.
33.4 Бросить исключение (throw) — ключевое слово, используется для возбуждения исключения.
     Мы знаем, что Java Runtime начинает поиск обработчика исключений как только оно будет брошено, но часто нам самим нужно генерировать исключение в нашем коде,
     например, в программе авторизации, если какое-то поле null. Именно для таких случаем и существует возможность бросить исключение.

34. Назовите основные методы класса Object?