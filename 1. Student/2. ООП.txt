Контрольные вопросы часть 2. ООП.

1. Что такое ООП?
1.1 ООП - методология программирования, в основе которой лежат объекты, каждый из которых является экземпляром определённого класса.

2. Базовые концепции ООП?
2.1 Инкапсуляция - механизм, который связывает код и данные которыми он манипулирует, сохраняя их в безопасности,
    как от внешнего так и от ошибочного внутреннего использования.
2.2 Наследование - процесс, когда один объект получает св-ва другого.
2.3 Полиморфизм - принцип ООП, который позволяет использовать один и тот же объект для общего класса действий (много форм).

3. Укажите из каких элементов состоит класс.
Класс состоит из следующих элементов:
Поля - параметры, которыми манипулирует класс.
Конструктор - то, что создает объекты данного класса.
Методы - действия, которые производит класс.

4. Что такое конструктор? Типы конструкторов?
4.1 Конструктор - это специальный метод, который вызывается при создании нового объекта.
    Конструктор инициализирует объект непосредственно во время создания.
    Имя конструктора совпадает с именем класса, включая регистр, а по синтаксису конструктор похож на метод без возвращаемого значения.

class Box {
    //1. Поля
    int width; // ширина коробки
    int height; // высота коробки
    int depth; // глубина коробки

    //2. Конструктор
    Box() {
        width = 10;
        height = 10;
        depth = 10;
    }

    //3. Методы
    //3.1 Вычисление объёма коробки
    int getVolume() {
    	return width * height * depth;
    }
}
4.2 В Java есть три типа конструктора:
    1) Конструктор без аргументов (по-умолчанию).
       Если мы не определяем конструктор в класса, то компилятор создает конструктор по-умолчанию для класса.
       И если мы пишем свой конструктор с аргументами или без аргументов, то компилятор не создает конструктор по-умолчанию.
       Конструктор по-умолчанию задает нулевые значения полей объекта класса в зависимости от типа при создании объекта.
    2.1) Параметризованный конструктор.
        Box(int w, int h, int d) {
            this.width = w;
            this.height = h;
            this.depth = d;
        }
    2.2) Параметризованный конструктор с обобщением типов.
        class GenConstructor
        {
         private double val;

         <T extends Number> GenConstructor(T arg)
         {
            val = arg.doubleValue();
         }

         void printValue()
         {
            System.out.println("val: "+val);
         }
        }

        class GenConstructorDemo
        {
         public static void main(String args[])
         {
            GenConstructor gc1 = new GenConstructor(100);
            GenConstructor gc2 = new GenConstructor(123.5F);

            gc1.printValue();
            gc2.printValue();
         }
        }
    3) Параметризированные конструкторы с аргументами переменной длины.
       Параметр, содержащий переменное число аргументов должен обязательно быть последним в списке параметров.
        class Checking
        {
            public Checking(String s, int ... n)
            {
            }
        }
4.3 Характеристики конструктора:
    - Имя конструктора должно совпадать с именем класса;
    - Конструктор имеется в любом классе. Даже если вы его не написали, компилятор Java сам создаст конструктор по умолчанию (default constructor),
      который будет пустым и не делает ничего, кроме вызова конструктора суперкласса Object;
    - Конструкторов может быть несколько в классе. В этом случае конструкторы называют перегруженными;
    - Конструктор не имеет возвращаемого типа, им не может быть даже тип void, если возвращается тип void, то это уже не конструктор а метод, несмотря на совпадение с именем класса.
    - В конструкторе допускается применение модификаторов доступа, можно задать один из модификаторов: public, protected, private или без модификатора.
    - Конструктор не может иметь модификаторов abstract, final, native, static или synchronized;
    - Ключевое слово this cсылается на другой конструктор в этом же классе. Если используется, то обращение должно к нему быть первой строкой конструктора;
    - Ключевое слово super вызывает конструктор родительского класса. Если используется, должно обращение к нему быть первой строкой конструктора;
    - Если в классе определен параметризированный конструктор, то вызов конструктора по-умолчанию приведет к ошибке.
4.4 Передача параметров в конструктор:
    1. В языках программирования существует в основном два вида параметров:
    - основные типы (примитивы);
    - ссылки на объекты.
    Термин вызов по значению (call by value) означает, что  конструктор получает значение, переданное ему вызывающим модулем.
    В противоположность этому, вызов по ссылке (call by reference) означает, что конструктор получает от вызывающего модуля адрес переменной.
    2. В языке Java используется только вызов по значению. По значению параметра и по значению ссылки параметра.
    Java не использует вызов по ссылке для объектов (хотя многие программисты и авторы некоторых книг это утверждают).
    Параметры при передаче объектов в Java осуществляются не по ссылке, а по значению ссылки на объекты !
    В любом случае конструктор получает копии значений всех параметров.
    3. Конструктор не может делать со своими входными параметрами:
    - конструктор не может менять значения входных параметров основных (примитивных) типов;
    - конструктор не может изменять ссылки входных параметров;
    - конструктор не может переназначать ссылки входных параметров на новые объекты.
    4. Конструктор МОЖЕТ делать со своими входными параметрами:
    - изменять состояние объекта, передаваемого в качестве входного параметра.

5. Можно ли наследовать конструктор?
   Конструктор родительского класса не наследуется в дочернем классе,
   и поэтому super () автоматически добавляется в конструктор дочернего класса, если нет явного вызова super или this.

6. Что такое перегрузка конструктора?
    6.1 Перегрузка конструктора - когда внутри одного класса определяются 2 или более конструктора с одним и тем же именем,
        но они различаются по кол-ву параметров в аргументе.
    6.2 Перегрузка конструкторов - когда онструкторы одного класса могут иметь одинаковое имя и различную сигнатуру (аргументы).
        Сигнатура конструктора – это количество и типы параметров, а также последовательность их типов в списке параметров конструктора.
    6.3 Пример кода:
        Box() {}; //конструктор по-умолчанию
        Box(int w, int h, int d) { //параметризированный конструктор
            this.width = w;
            this.height = h;
            this.depth = d;
        }
        Box(int cube) { //перегрузка параметризированного конструктора
            this.width = cube;
            this.height = cube;
            this.depth = cube;
        }

7. Что такое статический метод?
7.1 Статические методы — это методы в Java, которые можно вызывать без создания объекта класса.
    Статическое ключевое слово может использоваться с классом, переменной, методом и блоком.
    Статические члены принадлежат классу, а не конкретному экземпляру, это означает, что если вы сделаете член статическим,
    вы сможете получить к нему доступ без объекта.
    Статические члены являются общими для всех экземпляров (объектов) класса, но нестатические члены являются отдельными для каждого экземпляра класса.
7.2 Интересные моменты:
    1) Доступ к членам и методам:
       В статическом методе метод может получить доступ только к статическим членам данных и статическим методам другого класса или того же класса,
       но не может получить доступ к нестатическим методам и переменным. Также статический метод может переписать значения любого статического члена данных.
    2) Процесс вызова:
       В статическом методе память статического метода фиксируется в оперативной памяти, по этой причине нам не нужен объект класса,
       в котором статический метод определен для вызова статического метода. Для вызова метода нам нужно написать имя метода, а затем имя класса:
       Config.init();
    3)Выделение памяти:
       В статическом методе распределение памяти происходит только один раз, потому что ключевое слово static фиксировало определенную память
       для этого метода в ram. Поэтому, когда метод вызывается каждый раз в программе, каждый раз, когда используется определенная память.
       По этой причине выделяется меньше памяти.
7.3 Важные моменты:
    - Они предназначены для совместного использования всеми объектами, созданными из одного класса.
    - Статические методы не могут быть переопределены.
    - Не могут напрямую обращаться к методам экземпляра и переменным экземпляра.


8. Что такое не статический метод?
8.1 Не статический метод - метод без ключевого слова static перед именем метода.
8.2 Интересные моменты:
    1) Доступ к членам и методам:
       В нестатическом методе метод может получить доступ к статическим членам данных и статическим методам,
       а также к нестатическим членам и методу другого класса или того же класса, а также может изменить значения любого статического члена данных.
    2) Процесс вызова:
       В нестатическом методе память нестатического метода не фиксирована в оперативной памяти, поэтому нам нужен объект класса для вызова
       нестатического метода. Для вызова метода нам нужно написать имя метода, а затем имя объекта класса.
       Config config = new Config();
       config.init();
    3) Выделение памяти:
       В нестатическом методе здесь выделение памяти происходит, когда метод вызывается и память выделяется каждый раз, когда вызывается метод.
       Так много памяти используется здесь.

9. Для чего используется ключевое слово this?
   Ключевое слово this используется в двух случаях:
9.1 Когда одинаковые имена у поля класса и переменной метода/конструктора;
9.2 Когда нужно вызвать конструктор одного типа (например, конструктор по умолчанию или параметризированный) из другого.
Это еще называется явным вызовом конструктора.
9.3 Пример кода для 9.1, 9.2:
class Human{
    int age;
    int weight;
    int height;

    Human(int age, int weight){
        this.age = age;       //9.1
        this.weight = weight; //9.1
    }

    Human(int age, int weight, int height){
        //вы вызываете конструктор с двумя параметрами
        this(age, weight); //9.2
        //и добавляете недостающую переменную
        this.height = height;
    }
}

10. Какой класс является базовый родительным классов для всех классов?
Все классы исходят от суперкласса Object

11. Что такое наследование? Приведите примеры из реальной жизни.
    Наследование - это когда один объект получает свойства другого, добавляя их к своим.
    К примеру есть класс Car("Машина"), которая является родителем для классов: седан, универсал и малолитражный хэтч-бэк.
    Иили есть класс Fiqure("Фигура") и у нее могут быть потомки: квадрат, треугольник, шестриугольник и тд.

12. Опишите процесс создания нового объекта.
12.1 Создание объектов в java проходит через 2 этапа:
     1 этап: Объявляем переменную с типом класса Box
     Box myBox; //объявляем ссылку на объект
     2 Этап: Получение конкретной, физической копии объекта
     myBox = new Box(); //выделяет память под объект Box и возвращает ссылку на адрес памяти
12.2 Оператор new резервирует память под объект и возвращает ссылку на него.
     Эта ссылка представляет собой адрес объекта в памяти, зарезервированной оператором new.
     Затем эта ссылка сохраняется в переменной.
     В результате переменная myBox содержит адрес памяти конкретного объекта типа Box.

13. Как вызвать метод из родительского класса?
    Ключевое слово super можно использовать для вызова конструктора суперкласса и для обращения к члену суперкласса, скрытому членом подкласса

14. Что такое переопределение метода?
14.1 Переопределение это - когда подкласс обеспечивает свою реализацию метода, чем в суперклассе.
14.2 Пример кода:
public class Bear extends Animal {
    public void voice() { р-р-р-р;}
}

public class Cat extends Animal {
    public void voice() { мяу!;}
}

15. Можно ли переопределить статический метод?

16. Что такое виртуальная функция и используются ли они в Java?

17. Что такое перегрузка метода?
17.1 Перегрузка - когда внутри одного класса определяются 2 или более методов с одним и тем же именем,
но они различаются по типу и/или кол-ву параметров.
17.2 Пример кода 1:
void Test();
void Test(int a);
void Test(double b, int c);
17.3 Пример кода 2:
Если бы в Java отсутствовала перегрузка методов (как в Си), то необходимо было бы писать свои функции под каждый тип переменных: abs, labs, fabs.

18. Можно ли изменить тип возвращаемых тип данных при перегрузке метода?

19. Что такое множественное наследование? Как его можно реализовать в Java.

20. Что такое полиморфизм? Приведите примеры из реальной жизни.
20.1 Полиморфизм - свойство, которое позволяет использовать один и тот же интерфейс для общего класса действий
20.2 К методам полиморфизма относятся: перегрузка и переопределение.
     Перегрузка (overloading) - это когда методы имеют одно имя, но разный набор пар-ов (сигнатур).
     Переопределение метода (overriding) - это когда методы имеют одинаковую сигнатуру, но разную реализацию.
     Применяется только в подклассе, при наследовании.
20.3 Пример переопределения (в подклассе):
     class X{
       public int sum(){
          // some code
       }
     }
     class Y extends X{
       public int sum(){
         //overridden method
        //signature is same
      }
20.4 Пример перегрузки (в одном и том же классе):
    void sum (int a , int b);
    void sum (int a , int b, int c);
    void sum (float a, double b);
20.5 Пример. Есть класс Animal, у него есть метод sound(). Есть реализации подклассов Animal со своими звуками животных
     в методе sound() - это есть переопределение. А если в классе Animal объявить еще один метод sound в другой сигнатурой -
     это будет перегрузкой.

21. Что такое инкапсуляция?
21.1 Инкапсуляция - механизм, который связывает код и данные, которыми он манипулирует сохраняя их в безопасности,
     как от внешнего влияния (использования), так и от внешнего влияния (использования), так и от ошибочного (внутреннего)
     использования.
21.2 Инкапсуляция - защитная оболочка которая предохраняет код и данные от произвольного доступа от других кодов, определенных
     вне этой оболочки.
21.3 Пример инкапсуляции 1:
     Инкапсулированно:
     - двигатель
     - проводка
     - электронные устройства
     - бак, топливная система
     Выставлено наружу:
     - педали
     - руль
     - ручка, переключатель скоростей
     - ключ зажигания
     - кнопки на приборной доске
21.4 Пример инкапсуляции 2:
     Инкапсулированно:
     - электрические платы
     - кинескоп
     - трансформаторы
     Выставлено наружу:
     - кнопки
     - разъемы для подключения внешних устройств
     - пульт управления

22. Как реализована инкапсуляция в Java?
22.1 Как применяется инкапсуляция
     Есть несколько способов регулировать доступ к нашим данным. Основные это:
     - Модификаторы доступа (Access modifiers),
     - Геттеры и Сеттеры (Getters and Setters).
22.2 Преимущества инкапсуляции:
     - Поля класса можно сделать только для чтения или только для записи.
     - Класс может иметь полный контроль над тем, что хранится в его полях.
     - Если элемент данных объявлен как «закрытый», доступ к нему возможен
       только в пределах одного класса. Никакой внешний класс не может получить доступ к элементу данных (переменной) другого класса.
     - мы храним переменную и методы в одном месте. Это место «класс». Класс является основой для инкапсуляции.

23. Что такое абстракция?
23.1 Абстракция – это процесс скрытия деталей реализации от пользователя, предоставляя ему только функционал.
     Иными словами, пользователь будет владеть информацией о том, что объект делает, а не как он это делает.
23.2 Абстракция является основой объектно-ориентированного программирования и позволяет работать с объектами, не вдаваясь в особенности их реализации.

24. Как реализована абстракция в Java?
24.1 В Java абстракция достигается с использованием абстрактных классов и интерфейсов:
     Абстрактный класс - это класс, у которого не реализован один или больше методов.
     Абстрактный класс содержит в себе ключевое слово abstract, известен как абстрактный класс.
     - Абстрактные классы в Java могут содержать или не содержать абстрактные методы, т.е. методы без тела (public void get();)
     - Если класс имеет хотя бы один абстрактный метод, то класс должен быть объявлен абстрактным.
     - Если класс объявлен абстрактным, его нельзя реализовать.
     - Чтобы использовать абстрактный класс, вам нужно наследовать его из другого класса, обеспечить реализацию абстрактных методов в нём.
     - Если вы наследуете абстрактный класс в Java, вам нужно обеспечить реализацию всех абстрактных методов в нём.
24.2 Абстрактный метод.
     Если вы хотите, чтобы класс содержал конкретный метод, но вы желаете, чтобы фактическая реализация этого метода определялась дочерними классами,
     вы можете объявить метод в родительском классе как абстрактный.
     Ключевое слово abstract используется для объявления метода абстрактным.
     Вам нужно разместить ключевое слово abstract перед именем метода во время его объявления.
     Абстрактный метод в Java содержит сигнатуру метода, но не содержит тела метода.
     Вместо фигурных скобок у абстрактного метода будет точка с запятой (;) на конце.
24.3 Интерфейс — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет переменных класса.
24.4 Разница между абстрактными классами и интерфейсами?
     1) Интерфейс описывает только поведение. У него нет состояния. А у абстрактного класса состояние есть: он описывает и то, и другое.
     2) Абстрактный класс связывает между собой и объединяет классы, имеющие очень близкую связь.
        В то же время, один и тот же интерфейс могут реализовать классы, у которых вообще нет ничего общего.
     3) Классы могут реализовывать сколько угодно интерфейсов, но наследоваться можно только от одного класса.
24.5 Interface vs Abstract class?
      == Interface ==
     1) Interface support multimple implementations.
     2) Interface does not contain Data Member
     3) Interface does not contain Constructors
     4) An interface contains only incomplete member (signature of member)
     5) An interface cannot have access modifiers by default everything is assumed as public
     6) Member of interface can not be Static

      == Abstract Class ==
     1) Abstract Class does not support multiple inheritance
     2) Abstract Class contains Data Member
     3) Abstract Class contains Constructor
     4) An Abstract Class Contains both incomplete (abstact) and complete member
     5) An Abstract Class can contains access modifiers for the sub, functions, properties
     6) Only Complete Member of abstact class can be Static

25. Что такое интерфейс?
25.1 В языке Java подобную проблему частично позволяют решить интерфейсы.
     Интерфейсы определяют некоторый функционал, не имеющий конкретной реализации, который затем реализуют классы, применяющие эти интерфейсы.
     И один класс может применить множество интерфейсов.
     Чтобы определить интерфейс, используется ключевое слово interface. Например:

26. Что такое внутренний класс? Типы внутренних классов.
26.1 В Java есть 4 вида внутренних классов:
     1) Статические
     2) Нестатические
     3) Локальные – классы внутри методов или блока контекста {}.
     4) Анонимные – классы, которые создаются на ходу.
26.2 Статические внутренние классы, пример:
     public class Outer {
       public static class Nested {
       }
     }
     Чтобы создать экземпляр класса Nested, вы должны сослаться на него, добавив к нему префикс имени внешнего класса, например:
     Outer.Nested instance = new Outer.Nested();
     Может обращаться к переменным экземпляра включающего класса только через ссылку на его экземпляр.
26.3 Нестатические внутренние классы
     Нестатические вложенные также называются внутренними и связаны с экземпляром включающего класса.
     Таким образом, вы должны сначала создать экземпляр окружающего класса, чтобы создать экземпляр внутреннего:
     public class Outer {
       public class Inner {
       }
     }
     Вот как вы создаете экземпляр класса Inner:
     Outer outer = new Outer();
     Outer.Inner inner = outer.new Inner();
     Обратите внимание, как вы ставите new после ссылки на внешний класс, чтобы создать экземпляр внутреннего.
     Нестатические классы (внутренние классы) имеют доступ к полям включающего класса, даже если они объявлены закрытыми:
26.4 Статья: https://javarush.ru/groups/posts/vidy-vlozhennyh-klassov
     В данном примере, нам нужно создать крылья для самолета – левое и правое. Давайте создавать!
26.4.1 = Нестатические классы =
    Экземпляр внутреннего класса может существовать только тогда, когда существует конкретный экземпляр внешнего класса.
    Такая логическая связь обусловливает синтаксис создания объектов: сначала создаётся объект внешнего класса, позднее на его основе создаётся объект внутреннего класса.
    Внутренние нестатические классы описываются внутри основного внешнего класса. Экземпляры таких классов имеют доступ к public, protected, default и private полям внешнего класса.
    А также статическим и нестатическим методам внешнего экземпляра с любыми модификаторами доступа.
    За счёт того, что экземпляры внутреннего класса всегда логически привязаны к экземплярам окружающего класса, они не могут содержать (хотя могут наследовать от предка) определение статических полей, методов и классов (кроме констант).[1]
    Пример объявления внутреннего класса:
    class OuterClass {

        private int outerField;

        class InnerClass {
            int getOuterField() {
                return OuterClass.this.outerField; // эта строчка кода демонстрирует концепцию замыкания.
            }
        }
    }
    Создание описанного класса можно описать следующим блоком кода: OuterClass.InnerClass inner = new OuterClass().new InnerClass();
26.4.2
     Теперь мы хотим добавить крылья. Создавать отдельный класс? Возможно в этом и есть логика, если у нас сложная программа для конструирования самолетов,
     и где нам нужно создавать огромное количество производных классов (классы, которые обладают такой же логикой, как и родительский класс, то есть класс,
     от которого они наследуются, но так же расширяют родительский класс, добавляя логику или более подробные характеристики),
     но что, если у нас просто игра, где у нас есть один самолет? Тогда нам будет рациональней укомплектовать всю структуру в одном месте (в одном классе).
     public class Airplane {
         private String name, id, flight;
         private Wing leftWing = new Wing("Red", "X3"), rightWing = new Wing("Blue", "X3");

         public Airplane(String name, String id, String flight) {
             this.name = name;
             this.id = id;
             this.flight = flight;
         }

         private class Wing {
             private String color, model;

             private Wing(String color, String model) {
                 this.color = color;
                 this.model = model;
             }
             // getters/setters
         }
         // getters/setters
     }
     Так мы создали нестатический вложенный класс Wing (крыло) внутри класса Airplane (самолет), и добавили две переменные –
     левое крыло и правое крыло. И у каждого крыла есть свои свойства (цвет, модель), которые мы можем изменять.
     Так можно укомплектовывать структуры столько, сколько нужно.

     == Особенности нестатических вложенных классов Java: ==
     1) Они существуют только у объектов, потому для их создания нужен объект. Другими словами: мы укомплектовали наше крыло так, чтобы оно было частью самолета,
        потому, чтобы создать крыло, нам нужен самолет, иначе оно нам не нужно.
     2) Внутри Java класса не может быть статических переменных. Если вам нужны какие-то константы или что-либо еще статическое, выносить их нужно во внешний класс.
        Это связано с тесной связью нестатического вложенного класса с внешним классом.
     3) У внутреннего класса полный доступ ко всем приватным полям внешнего класса. Данная особенность работает в две стороны.
     4) Можно получить ссылку на экземпляр внешнего класса. Пример: Airplane.this – ссылка на самолет, this – ссылка на крыло.
26.5 = Статические классы =
26.5.1
    Декларируются внутри основного класса и обозначаются ключевым словом static. Объекты таких классов не имеют доступа к членам внешнего класса за исключением статических.
    Это обусловлено тем, что для создания такого класса не используется конкретный объект внешнего класса и в момент исполнения кода внутреннего класса, объекта внешнего может вовсе не быть.
    Экземпляры статических вложенных классов могут содержать статические поля, методы и классы, в отличие от других типов внутренних классов.

    Пример объявления вложенного статического класса:
    class OuterClass {

        private int outerField;
        static int staticOuterField;

        static class StaticInnerClass {
            int getOuterField() {
                return OuterClass.this.outerField; // эта строчка кода приведёт к ошибке компиляции.
            }
            int getStaticOuterField() {
                return OuterClass.staticOuterField; // эта строчка кода корректна.
            }
        }
    }
    Создание описанного статического вложенного класса можно описать следующим блоком кода: OuterClass.StaticInnerClass staticInner = new OuterClass.StaticInnerClass();

26.5.2 Для создания экземпляра такого класса, нужно через точку перечислить весь путь от внешнего класса до нужного.
    Например: Building.Plaftorm platform = new Building.Platform();
    Статические классы используются для того, чтобы укомплектовать связанные классы рядышком, чтобы с логической структурой было работать проще.
    Например: мы можем создать внешний класс Building, где будет конкретный список классов, которые будут представлять из себя уже конкретную постройку.
26.5.3 Пример статического класса
      public abstract class Building {
          private String name, address, type;

          Building(String name, String address) {
              this.name = name;
              this.address = address;
          }

          public static class Platform extends Building {
              public Platform(String name, String address) {
                  super(name, address);
                  setType("Platform");
              }

              // some additional logic
          }

          public static class House extends Building {
              public House(String name, String address) {
                  super(name, address);
                  setType("House");
              }

              // some additional logic
          }

          public static class Shop extends Building {
              public Shop(String name, String address) {
                  super(name, address);
                  setType("Shop");
              }

              // some additional logic
          }

          // getters/setters
      }
     Плюсы такого подхода:
     1) Количество классов уменьшилось.
     2) Все классы внутри их класса-родителя. Мы способны прослеживать всю иерархию без открытия каждого класса отдельно.
     3) Мы можем обратиться к классу Building, а IDE уже будет подсказывать весь список всех подклассов данного класса.
        Это будет упрощать поиск нужных классов и показывать всю картину более цело.
     Пример создания экземпляра вложенного статического класса:Building.Shop myShop = new Building.Shop(“Food & Fun!”, “Kalyaeva 8/53”);
26.6 = Локальные классы =
26.6.1 Локальные классы
       Декларируются внутри методов основного класса. Могут быть использованы только внутри этих методов. Имеют доступ к членам внешнего класса.
       Имеют доступ как к локальным переменным, так и к параметрам метода при одном условии - переменные и параметры, используемые локальным классом, должны быть задекларированы final.
       Не могут содержать определение (но могут наследовать) статических полей, методов и классов (кроме констант).[2]
       Пример:
       class OuterClass {

           private int outerField;

           void methodWithLocalClass(final int finalParameter) {
               int notFinalVar = 0;
               notFinalVar++;

               class InnerLocalClass {
                   void getOuterField() {
                       int a = notFinalVar; // эта строчка кода приведёт к ошибке компиляции. no-final переменные вне контекста недоступны.
                       int b = OuterClass.this.outerField; // эта строчка кода демонстрирует обращение члену обрамляющего класса.
                   }

                   int getParameter() {
                       return finalParameter; // эта строчка кода демонстрирует обращение к final переменной вне контекста.
                   }
               }
           }
       }
26.6.2 Данные классы объявляются внутри других методов. По сути, они обладают всеми свойствами нестатического вложенного класса,
    только создавать их экземпляры можно только в методе, при чем метод не может быть статическим.
    Плюсы локального класса:
    1) Локальные классы способны работать только с final переменными метода. Все дело в том, что экземпляры локальных классов способны сохраняться в «куче» после завершения работы метода, а переменная может быть стёрта. Если же переменная объявлена final, то компилятор может сохранить копию переменной для дальнейшего использования объектом. И еще: с 8+ версий Java можно использовать не final переменные в локальных классах, но только при условии, что они не будут изменяться.
    2) Локальные классы нельзя объявлять с модификаторами доступа.
    3) Локальные классы обладают доступом к переменным метода.
    Локальные классы можно встретить крайне редко, так как они затрудняют прочтение кода и не обладают никакими плюсами,
    кроме одного – доступ к переменным метода. Я не знаю, какой можно взять пример локального класса, который бы показал их эффективное применение,
26.7 = Анонимные классы =
26.7.1 Декларируются внутри методов основного класса. Могут быть использованы только внутри этих методов. В отличие от локальных классов, анонимные классы не имеют названия.
     Главное требование к анонимному классу - он должен наследовать существующий класс или реализовывать существующий интерфейс.
     Не могут содержать определение (но могут наследовать) статических полей, методов и классов (кроме констант). Пример:

     class OuterClass {
         /**
         *   При определении анонимного класса применен полиморфизм — переменная listener
         *   содержит экземпляр анонимного класса, реализующего существующий
         *   интерфейс ActionListener.
         **/
         void methodWithAnonymousClass(final int interval) {
             ActionListener listener = new ActionListener() {
                 public void actionPerformed(ActionEvent event) {
                     System.out.println("Эта строка выводится на экран каждые " + interval + " секунд.");
                 }
             };

             Timer t = new Timer(interval, listener); // объект анонимного класса использован внутри метода.
             t.start();
         }
     }
26.7.1 Использование анонимных классов оправдано во многих случаях, в частности когда:
    1) тело класса является очень коротким;
    2) нужен только один экземпляр класса;
    3) класс используется в месте его создания или сразу после него;
    4) имя класса не важно и не облегчает понимание кода.
    Аналог с лямбдами:
    JButton b2 = new JButton("Click");
    b2.addActionListener(e -> System.out.println("Кнопка нажата!"));

27. Что такое анонимный класс.
27.1 Анонимный класс - вложенный класс без имени.
27.2 Статья
https://javarush.ru/groups/posts/1553-urovenjh-24-otvetih-na-voprosih-k-sobesedovaniju-po-teme-urovnja
27.3 См. п.26.7

28. Для чего используется конструктор в абстрактном классе?
28.1 В абстрактном классе могут быть неабстрактные свойства, поля и методы.
     Для инициализации свойств и полей - кокраз таки и используется конструктор.
28.2 Чтобы в каждом конструкторе наследника не писать одно и то же.
28.3 Статья (10 вопросов по абстрактным классам и интерфейсам с собеседований по Java)
https://javarush.ru/groups/posts/431-10-voprosov-po-abstraktnihm-klassam-i-interfeysam-s-sobesedovaniy-po-jazihku-java

--29.Можно ли создать анонимный класс. если в классе нет конструктора по умолчанию?
29.1 У всех классов всегда есть конструктор.
     Если вы не определяете его явно, компилятор сделает это за вас. В том числе для анонимных классов.

30-31.Что такое композиция/агрегация?
30.1 Композиция, агрегация и ассоциация — все эти термины или точнее парадигмы ООП про отношения между объектами или классами между собой. Всего существует пять основных типов отношений:
    — Ассоциация
    — Агрегарция
    — Композиция
    и еще два типа, которые в этой статье рассматривать не будем:
    — Наследования (иногда этот тип еще называют генерализацией)
    — Реализация (это тип отношений базируется на интерфейсах. То есть создается интерфейсы, которые основной класс должен реализовать.)
30.2 Самый простой способ понять эти термины это использовать аналогию из реального мира. Представим себе что у нас есть класс комната
     и есть два других класса мебель и стена. Мы можем сказать что у комнаты будет какая та мебель и какие то стены.
     То есть объект комната может использоваться объекты стены и мебель по мере необходимости. Но есть разница в отношения комната — стены и комната — мебель.
     Разница в том что стены никогда не выйдут из объекта комната. Стены не могут существовать вне комнаты.
     То есть стена всегда будет создаваться внутри объекта комната. Такая связь называется композиция. И эта связь будет жесткой.
     Зато мебель очень легко представить за пределами комнаты. Один экземпляр мебели может принадлежать с начало одной комнате потом другой.
     Такая связь называется ассоциацией или агрегацией. И такая связь будет более гибкой. О различие между ассоциацией или агрегацией чуть позже.

     Способ реализации отношений между классами или объектами и есть основное концептуальное различие между композицией, агрегацией и ассоциацией .
     При композиции мы не можем что то вынести а при агрегации или ассоциации мы можем передать объект из одного объекта в другой.

    Композиция, агрегация и ассоциация эти три понятия очень похожи друг на друга. Все они означают что внутри одного объекта будет существовать другой объект.
30.3 Отношения между классами:
     * Ассоциация *
     Ассоциация это такой тип при котором объекты будут ссылаться друг на друга.
     При этом они остаются полностью независимыми друг от друга.
     * Агрегация *
     Агрегация это тип отношений когда один объект является частью другого. Агрегация образует слабую связь между объектами.
     Все зависимые классы инициализируются вне основного объекта.
     * Композиция *
     Композиция это тип отношений при котором один объект может принадлежать только другому объекту и никому другому.
     При композиции образуется сильная связь между объектами. При таком типе отношений основной объект полностью обеспечивает
     жизненный цикл объектов от которых он зависит. Используем еще один пример из реальной жизни. Возьмем машину и двигатель.
     Машина и двигатель конечно могут существовать друг без друга, но суть не в этом. А в том что при конкретной реализации рабочей машины,
     один двигатель может принадлежать только одной машине, поэтому для такой связи логично использовать композицию.
30.4 Отношения между классами №2:
     * Ассоциация *
     Ассоциация означает, что объекты двух классов могут ссылаться один на другой, иметь некоторую связь между друг другом.
     Например Менеджер может выписать Счет. Соответственно возникает ассоциация между Менеджером и Счетом.
     Еще пример — Преподаватель и Студент — т.е. какой-то Студент учится у какого-то Преподавателя.
     Ассоциация и есть описание связи между двумя объектами. Студент учится у Преподавателя.
     Идея достаточно простая — два объекта могут быть связаны между собой и это надо как-то описать.
     * Агрегация *
     Агрегация — отношение когда один объект является частью другого. Например Студент входит в Группу любителей физики.
     * Композиция *
     Композиция — еще более «жесткое отношение, когда объект не только является частью другого объекта, но и вообще не может принадлежат еще кому-то.
     Например Машина и Двигатель. Хотя двигатель может быть и без машины, но он вряд ли сможет быть в двух или трех машинах одновременно.
     В отличии от студента, который может входить и в другие группы тоже. Такие описания всегда несколько условны, но тем не менее.
30.1 = Композиция: объект A управляет временем жизни объекта B =
    Плюсы:
    Композиция позволяет скрыть отношение использования объектов от глаз клиента.
    Делает API использования класса более простым и позволяет перейти от использования одного класса, к другому
    (например, StringWriter мог бы поменять реализацию и начать использовать другой тип, например CustomStringBuilder).

    Минусы:
    Отношение достаточно жесткое, поскольку один объект должен уметь создавать другой: он должен знать конкретный тип
    и иметь доступ к функции создания. Композиция не позволяет использовать интерфейсы (без привлечения фабрик) и требует,
    чтобы класс имел доступ к конструктору другого класса: представьте, что конструктор StringBuilder-а является внутренним
    или же это интерфейс IStringBuilder и только клиенский код знает, какой экземпляр должен использоваться здесь и сейчас.

30.2 = Агрегация: объект А получает ссылку на объект B =
    Плюсы:
    Более слабая связанность между объектом и его клиентом. Теперь мы можем использовать интерфейсы
    и одному объекту не нужно знать, как именно создавать другой объект.
    Большая гибкость. Вытекает из первого пункта

    Минусы:
    Выставление наружу деталей реализации. Поскольку клиент класса должен предоставить зависимость в момент создания объекта
    (передать экземпляр StringBuilder-а в момент создания StringWriter-а, то сам факт этого отношения становится известен клиенту.
    Из первого пункта вытекает увеличение сложности в работе клиентов, а также большая "жесткость" решения в долгосрочной перспективе.
    Теперь автор класса TextWriter уже не может принять решение самостоятельно и перейти от StringBuilder-а к чему-то другому. Да, можно "добавить еще один уровень абстракции" и выделить интерфейс IStringBuilder, но разорвать это отношение совсем будет невозможно без поломки всех существующих клиентов.
30.1 Примеры из реальной жизни:
    ... отвертка. Если отвертка цельная, т.е. ручка и насадка намертво связаны друг с другом, то мы имеем отношение композиции.
    Если же насадка съемная и может существовать без ручки или же использоваться с другой ручкой, то мы имеем отношение агрегации.

30.2 Статья: https://hr-vector.com/java/otnosheniya
     Статья: https://webdevblog.ru/prosto-o-kompozicii-agregacii-i-associacii-v-javascript/

32. Какие типы исключительных ситуаций бывают?
32.1 Все исключения делятся на 2 вида: -> checked (проверяемые),
                                       -> unchecked (непроверяемые).
32.2 Checked (проверяемые) исключения происходят от Exception. Компилятор java знает о самых
     распространенных исключениях и знает, в каких ситуациях они могут возникнуть. Например, когда
     программист считывает данные из файла, может возникнуть, что файла не существует. Поэтому
     компилятор заранее проверяет наш код на наличие потенциальных исключений. Если он их найдет, то не скомпилирует
     код, пока мы их не обработаем.
     К Checked относятся: IOException, FileNotFound, SQLException.
32.3 Unchecked (непроверяемые) исключения происходят от класса Runtime exception. Этих ошибок компилятор не ожидает.
     Люди сами создают эти ошибки своими руками, поэтому компилятор не будет проверять обработку таких исключений в коде.
     К Unchecked относятся: ArithmeticException (при делении на 0), ArrayIndexOfBoundsException (при выходе индекса за диапазон).
32.4 Checked exception - they MUST BE handled by using try-catch or using by throws clause on methods. (-> Exception)
     Unchecked exception - can OPTIONALLY BE handled, the same way checked exception are handled. (-> Runtime Exception)
32.5 Ситуации при которых восстановление нормальной работы программы невозможно -> unchecked (это Error + RuntimeException).
     К первой группе относятся ситуации, унаследованные из класса Error. Это ошибки, возникающие в программе в результате сбоя работы JVM,
     переполнения памяти, сбоя системы. Такой тип исключений является неконтролируемыми (unchecked) на стадии компиляции.
     Поэтому их обработка не является обязательной.

     Ко второй группе относятся исключения, предвидимые компилятором на стадии написания программы, для которых должен быть написан код обработки.
     Разработчик должен их оборабатывать. Проверка checked исключения происходит в момент компиляции.
     Восстановление возможно -> checked
32.6 Throwable — родительский класс в иерархии Java исключений.
     Он имеет два дочерних объекта — Error и Exception.
     Исключения далее разделены на проверяемые исключения и исключения времени выполнения.
32.7 Иерархия исключений:
                  Object
                    |
                 Thowable
               / (checked) \
              /             \
             /            Error ------ IOError
            /          (unchecked) --- OutOfMemory
       Exception
          |     \
          |      \
          |     Runtime exception --+-- NPE (NullPointerException)
          |       (unchecked)       +-- ArithmeticException
          |                         +-- IndexOfBoundException
      (checked)
     IOException,
     SQLException,
     FileNotFound
      Exception
32.8 Статья:
https://javadevblog.com/polnoe-rukovodstvo-po-obrabotke-isklyuchenij-v-java.html

33. Как обрабатываются исключительные ситуации?
33.1 try - определяет блок кода, в котором может произойти исключение. catch - определяет блок кода, в котором происходит обработка исключений,
     finally - блок кода (необязательный), но при его наличии, выполняется в любом случае, независимо от результатов выполнения.
     Блок try-catch используется для обработки исключений в коде. Слово try — это начало блока обработки, catch — конец блока для обработки исключений.
     Мы можем использовать сразу несколько блоков catch при одном try. catch в качестве параметра принимает тип исключения для обработки.
33.2 finally — необязательная завершающая конструкция блока try-catch. Как только исключение остановило процесс исполнения программы, в finally мы можем
     безопасно освободить какие-то открытые ресурсы. Следует отметить, что finally блок выполняется всегда — не смотря на появление исключительной ситуации.
33.3 throws — когда мы бросаем исключение в методе и не обрабатываем его, то мы должны использовать ключевое слово throws в сигнатуре метода для того,
     чтобы пробросить исключение для обработки в другом методе. Вызывающий метод может обработать это исключение или пробросить его еще дальше с помощью throws в сигнатуре метода.
     Следует отметить, что пробрасывать можно сразу несколько исключений.
     throws - используется в сигнатуре для предупреждения, о том, что метод может выбросить исключение.
33.4 Бросить исключение (throw) — ключевое слово, используется для возбуждения исключения.
     Мы знаем, что Java Runtime начинает поиск обработчика исключений как только оно будет брошено, но часто нам самим нужно генерировать исключение в нашем коде,
     например, в программе авторизации, если какое-то поле null. Именно для таких случаем и существует возможность бросить исключение.

34. Назовите основные методы класса Object?
34.1 Метод toString() служит для получения представления данного объекта в виде строки.
    public class Program{
        public static void main(String[] args) {
            Person tom = new Person("Tom");
            System.out.println(tom.toString()); // Person Tom
        }
    }
    class Person {
        private String name;

        public Person(String name){
            this.name=name;
        }

        @Override
        public String toString(){
            return "Person " + name;
        }
    }
    == getClass().getName() + '@' + Integer.toHexString(hashCode()) ==

34.2 Метод hashCode позволяет задать некоторое числовое значение, которое будет соответствовать данному объекту или его хэш-код.
     По данному числу, например, можно сравнивать объекты.

    Например, выведем представление вышеопределенного объекта:
    Person tom = new Person("Tom");
    System.out.println(tom.hashCode()); // 2036368507

    Но мы можем задать свой алгоритм определения хэш-кода объекта:
    class Person {

        private String name;

        public Person(String name){

            this.name=name;
        }

        @Override
        public int hashCode(){

            return 10 * name.hashCode() + 20456;
        }
    }
34.3 Метод equals() сравнивает два объекта на равенство:
    public class Program{
        public static void main(String[] args) {

            Person tom = new Person("Tom");
            Person bob = new Person("Bob");
            System.out.println(tom.equals(bob)); // false

            Person tom2 = new Person("Tom");
            System.out.println(tom.equals(tom2)); // true
        }
    }

    class Person {
        private String name;

        public Person(String name){
            this.name=name;
        }

        @Override
        public boolean equals(Object obj){
            if (!(obj instanceof Person)) return false;

            Person p = (Person)obj;
            return this.name.equals(p.name);
        }
    }