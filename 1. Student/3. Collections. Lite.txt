Контрольные вопросы. Раздел 3. Collections. Lite

1. Что такое "коллекция". 

1.1. Перечислите основные методы из интерфейса java.util.Collection.
Наиболее важные методы:  size(), iterator(), add(), remove(), clear().
Каждая коллекция должна реализовывать эти методы.
        // Методы работы со списом List:
        // 1) add(element) - добавление элемента в конец списка
        // (--) 2) get(index) - получение элемента по индексу -> для списков List
        // 3) indexOf(element) - получение индекса элемента для переданного элемента
        // 4) contains(element) - сообщает о присутствии элемента в коллекции
        // 5) set(index, new_value) - update, обновление данных по индексу
        // 6) remove(index/value) - удаление элемента по индексу/значению
        // 7) size() - размер, число элементов в коллекции
        // 8) isEmpty() - возвращает true, если коллекция пуста, иначе возвращает false
        // 9) clear (): удаляет все элементы из коллекции

2. Назовите преимущества использования коллекций.
2.1 - Повторное использование и совместимость.
    - Хорошо реализовано, требует меньше усилий (уже реализовано),
    - Гибкие по размеру наборы данных,
    - Реализованы различные алгоритмы и структуры данных:  стек, очередь, дерево и ряд других.

3. Какие данные могут хранить коллекции?
   Коллекции могут хранить любые ссылочные типы данных.

4. Какие есть типы коллекций? Как они характеризуются?
4.1 List - список, динамически изменяемый массив. Объекты хранятся в порядке их добавления.
4.2 Set - набор, исключает повторы (дубляжи).
4.3 Map - набор ключ-значение, еще называется словарь.
    Map является единственным интерфейсом, который не наследует интерфейс Collection,
    но является неотъемлемой частью коллекций.

5. Назовите основные реализации List, Set, Map.
5.1 Для интерфейса List: ArrayList, LinkedList.
5.2 Для интерфейса Set:  HashSet,   LinkedHashSet, TreeSet.
5.3 Для интерфейса Map:  HashMap,   LinkedHashMap, TreeMap.

6. В чём отличие ArrayList от LinkedList?
6.1 ArrayList - это список на основе динамического массива.
    Данная коллекция динамически увеличивает размер массива, если в нем не хватает места, при вызове методов add(T element), addAll(Collection<T> other).
    Так же она может его уменьшать, если размер больше количества хранимых элементов, методом trimToSize()
6.2 LinkedList - двусвязанный список, состоящий из узлов.
    В каждом узле, хранится ссылки на следующий/предыдующий узел и значение.
    В самом списке, есть ссылки на последний и первый узел, а так же размер.
6.3 ArrayList следует использовать, когда в приоритете доступ по индексу, так как эти операции выполняются за константное время.
    Добавление в конец списка в среднем тоже выполняется за константное время.
    Кроме того в ArrayList нет дополнительных расходов на хранение связки между элементами.
    Минусы в скорости вставки/удаления элементов находящихся не в конце списка, так как при этой операции все элементы правее добавляемого/удаляемого сдвигаются.
6.4 LinkedList удобен когда важнее быстродействие операций вставки/удаления, которые в LinkedList выполняются за константное время.
    Операции доступа по индексу производятся перебором с начала или конца (смотря что ближе) до нужного элемента. Дополнительные затраты на хранение связки между элементами.
6.5 Чтобы оценить эти структуры данных, можно прибегнуть к временной сложности выполнения операций:
    В LinkedList вставка осуществляется так: находится элемент, за которым должен следовать вставляемый элемент, изменяются ссылки в нем и следующим за ним.
    В ArrayList создается новый массив, если в текущем нет места. Те элементы которые находятся до вставляемого, остаются на месте, или копируются в новый.
    Далее добавляется вставляемый элемент. Затем копируются оставщиеся элементы, которые были в исходном.
     <<Вставка элемента >>    |  ArrayList  |  LinkedList
     add (в начало)           |     O(n)    |   O(1)
     add (в середину)         |     O(n)    |   O(n)
     add (в конец списка)     |     O(n)    |   O(1)
6.6 В LinkedList чтобы найти элемент с нужным индексом, нужно пройтись поочередно по ссылкам от первого элемента и до последнего (в худшем случае).
    В ArrayList получения элемента происходит простым взятием по индексу из массива.
     <<Получение по индексу>> |  ArrayList  |  LinkedList
     get (первый элемент)     |   O(1)      |   O(1)
     get (из середины)        |   O(1)      |   O(n)
     get (последний элемент)  |   O(1)      |   O(1)
6.7 В LinkedList удаление происходит аналогично вставке. В ArrayList, примерно, так же как и при добавлении.
    Как мы видем в среднем, сложности одинаковые. Но я бы не стал рекомендовать использовать LinkedList, за исключением ситуации когда, преобладает удаление или вставка в начало или конец списка.
     <<Удаление элемента>>       |  ArrayList  |  LinkedList
     delete (первый элемент)     |   O(n)      |   O(1)
     delete (из середины)        |   O(n)      |   O(n)
     delete (последний элемент)  |   O(1)      |   O(1)
6.8 Резюме: если часто вставляете/удаляете - выбирайте в пользу LinkedList, в противном случае ArrayList.
    Выбирайте LinkedList когда преобладает удаление или вставка в начало или конец списка.
    Если ты собираешься вставлять (или удалять) в середину коллекции много элементов, то тебе лучше использовать LinkedList. Во всех остальных случаях – ArrayList.
6.9 Когда использовать LinkedList:
    1. Необходимо много данных добавлять в начало списка
    2. Удалять с начала (index = 0) списка, т.е. элементы, которые были добавлены первыми.
    3. set в конце списка

    Когда использовать ArrayList:
    1. get
    2. set (начало и середина)
    3. add
    4. remove (кроме начала списка )

7. В чём отличие HashSet от TreeSet?
7.1 Начнем с того, что Set — это множество (так же называют «набором»). Set не допускает хранение двух одинаковых элементов.
    Формально говоря, термин «множество» и так обозначает совокупность различных элементов, очень важно,
    что именно различных элементов, так как это главное свойство Set. С учетом такого определения, пояснение про хранение одинаковых элементом не требуется,
    но в обиходе, понятие «множество» потеряло свой строгий смысл касательно уникальности элементов, входящих в него, поэтому все же уточняйте отдельно данное свойство множества.
7.2 TreeSet обеспечивает упорядоченно хранение элементов в виде красно-черного дерева.
    Сложность выполнения основных операций в TreeSet lg N.
7.3 HashSet использует для хранения элементов такой же подход, что и HashMap, за тем отличием,что в HashSet в качестве ключа выступает сам элемент,
    кроме того HashSet (как и HashMap) не поддерживает упорядоченное хранение элементов и обеспечивает временную сложность выполнения операций аналогично HashMap.

8. В чём отличие Set от Map?
8.1 Set – это множество (набор). Главная особенность Set – в нем только уникальные объекты, т.е. они все разныe.
8.2 Вот что с ним можно делать с Set:
    * Добавлять элемент(ы): add(), addAll(),
    * Удалять элемент(ы): remove(), removeAll(),
    * Проверять, есть ли элемент(ы): contains(), containsAll(),
    * Узнать количество элементов: с помощью метода size().
8.3 Map – это множество пар. То же множество, но не одиноких элементов, а пар: ключ-значение.
    Единственное ограничение: первый объект в паре, называемый ключом, должен быть уникальным.
    В Map не может содержаться две пары с одинаковыми ключами.
8.4 Вот что мы можем делать с Map:
    * Получить множество всех пар: entrySet(),
    * Получить множество всех ключей: keySet(),
    * Получить множество всех значений: values()
    * Добавить пару: put(key, value),
    * Получить значение по ключу: get(key),
    * Проверить наличие «ключа»: containsKey(key),
    * Проверить наличие «значения»: containsValue(value),
    * Проверить что Map — пустой: isEmpty(),
    * Очистить Map: clear(),
    * Удалить элемент по ключу: remove(key).

9. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?

10. Чем отличается Comparable от Comparator?

11. Что такое сортировка по принципу Natural Order?

12. Что такое equals и hashCode?
// ---------- Если equals и hashCode ДО переопределения ------------------
12.1 hashcode - число, целое 10-ти значное, в java ограничен целочисленным типом int.
12.2 Если в классе не переопределен метод equals(), то его исходный код из класса Object такой:
    public boolean equals(Object obj) {
        return (this == object)
    }
    При сравнении объектов, операция ==, equals возвращает true в одном случае - когда ссылки указывают
    на один и тот же объект. В данном случае не учитывает содержимое полей.
    Метод equals класса Object сравнивает ссылки, а не содержимое объектов.

// ---------- Если equals и hashCode ПОСЛЕ переопределения ------------------
12.3 Метод equals после переопределения у класса:
     сравнение объектов после переопределения более глубокое, с учетом сравнения полей объектов и ссылок.
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        BlackBox blackBox = (BlackBox) o;
        return varA == blackBox.varA &&
                varB == blackBox.varB;
    }
12.4 Метод hashCode после переопределения у класса:
    @Override
    public int hashCode() {
        return Objects.hash(varA, varB); //генерация хэш-кода происходит с учетом полей объекта: varA, varB
    }
12.5 Соглашение между equals и hashCode:
     * Если объекты равны (т.е. equals(Object a) == true), то хэш-коды этих объектов равны,
     ** Если хэш-коды равны, то вовсе не обязательно, что объекты равны.
12.6 Для класса String оператор == сравнивает по ссылкам (адресам),
     а метод equals() по значениям элементов.

13. Какие есть способы перебора всех элементов List?
13.1 Есть 4 варианта итерации всех элементов: 2 через цикл for, 1 через Iterator, 1 через Stream.
13.2 Четвертый вариант через Stream:
        System.out.println("4 Вариант. Обход через Stream:");
        lists.stream()
                //.forEach(System.out::print);
                .forEach(c -> System.out.println(c));

14. Как реализован цикл foreach?
14.1 Первый вариант обхода списка через цикл for:
        List<Integer> lists = new ArrayList<>();
        lists.add(20);
        lists.add(19);
        lists.add(18);
        lists.add(22);

        System.out.println("1 Вариант. Обход всех элементов через цикл for:");
        for (int i = 0; i < lists.size(); i++) {
            System.out.println(lists.get(i));
        }

14.2 Второй вариант через цикл for:
        System.out.println("2.1 Вариант. Обход всех элементов через цикл for:");
        for (Object value: lists) {
           System.out.println(value);
        }
15. В чем разница между Iterator?
15.2 Третий вариант через Iterator:
        System.out.println("3.3 Вариант. Обход через ListIterator:"); //может ходить в обе стороны: hasNext, hasPrevious, next, previous
        ListIterator iterator3 = lists.listIterator();
        while (iterator3.hasNext()) {
            System.out.println(iterator3.next());
        }
15.3 Разница такая, что перебор элементов через цикл for происходит через индекс списка List,
     + косвено известен размер этого списка или он задается в цикле, получение элемента через метод get().
     А при использовании итератора Iterator перед получением элемента проверяется его наличие методом hasNext,
     а получение элемента через метод next().
15.4 При использовании цикла for НЕЛЬЗЯ добавлять/удалять элементы из списка:
    //Пример №1 - так нельзя, ошибка java.util.ConcurrentModificationException
    for (Cat cat: cats) {
        cats.add(new Cat("Сейлем Сэйберхеген"));
    }
    //Пример №2 - так нельзя, ошибка java.util.ConcurrentModificationException
    for (Cat cat: cats) {
       if (cat.name.equals("Бегемот")) {
             cats.remove(cat);
       }
    }
15.5 При проходе через итераторы, МОЖНО удалять элементы:
     Iterator<Cat> catIterator = cats.iterator();//создаем итератор
     while(catIterator.hasNext()) {//до тех пор, пока в списке есть элементы
        Cat nextCat = catIterator.next();//получаем следующий элемент
        if (nextCat.name.equals("Филипп Маркович")) {
            catIterator.remove();//удаляем кота с нужным именем
        }
     }

16. Как происходит удаление элементов из ArrayList?
16.1 Удаление элемента из списка ArrayList:
     В основе структуры ArrayList лежит динамический массив. При превышении максимального на данный момент размера происходит увеличение в 1.5 раза.
     Причем начальный размер равен 10. Как и в vector, в ArrayList не предусмотрено изменение размера при удалении элементов.
     Для принудительного изменения размера следует использовать метод trimToSize().
     При удалении элементов из ArrayList, во-первых, уничтожается сам объект. Во-вторых, каждый объект после этой точки сдвигается на один элемент.
     Как и при добавлении к концу массива, удаление из конца массива является наилучшим случаем, потому что при этом нужно перемещать ноль объектов.
     Также стоит заметить, что нам не нужно изменять размер внутреннего массива, чтобы сделать его меньше.
     Выделенное место может оставаться таким же, на случай, если мы позже будем добавлять объекты.
     Сложность: O(n).
     Удаление элемента по индексу — операция, обратная вставке. Указанный элемент удаляется, а остальные сдвигаются на одну позицию влево.
16.2 Добавление элемента в конец списка.
     Сложность: O(1), если осталось более одного свободного места; O(n), если необходимо расширение массива.
16.3 Добавление элемента в середину/начало списка.
     Сложность: O(n).
     Вставка по определенному индексу требует сдвига всех элементов, начиная с этого индекса, на одну позицию вправо. Если внутренний массив заполнен, вставка потребует увеличения его размера.
16.4 Доступ к элементу по индексу:
     Сложность: O(1).
16.5 Поиск элемента:
     Сложность: O(n).
16.6 Итог:
     * Получение get(i) - O(1),
     * Запись set(i, new_value) - O(1),
     * Добавление add(value) - O(1) в лучшем случае (в конец), O(n) в худшем (в начало),
     * Удаление del - O(1) в лучшем (удаление в конце), O(n) в худшем (удаление в начале),
     * Размер size() - O(1).

17. Как происходит удаление элементов из LinkedList?
17.1 Удаление элемента из списка LinkedList:
     В основе структуры LinkedList лежит двухсвязанного.
     При удалении объекта из связанного списка находится узел перед удаляемым узлом.
     Он изменяется таким образом, чтобы указывать на следующий после удалённого объекта узел.
     После этого удалённый объект можно безопасно стереть.
     Сложность: O(1).
17.2 Добавление элемента в список конец/середину/начало.
     Сложность: O(1), если осталось более одного свободного места; O(n), если необходимо расширение массива.
     Вставка по определенному индексу требует сдвига всех элементов, начиная с этого индекса, на одну позицию вправо. Если внутренний массив заполнен, вставка потребует увеличения его размера.
17.4 Доступ к элементу по индексу:
     Сложность: O(n).
16.5 Поиск элемента:
     Сложность: O(n).
