Контрольные вопросы. Раздел 3. Collections. Lite

1. Что такое "коллекция". 

1.1. Перечислите основные методы из интерфейса java.util.Collection.
Наиболее важные методы:  size(), iterator(), add(), remove(), clear().
Каждая коллекция должна реализовывать эти методы.
        // Методы работы со списом List:
        // 1) add(element) - добавление элемента в конец списка
        // 2) get(index) - получение элемента по индексу
        // 3) indexOf(element) - получение индекса элемента для переданного элемента
        // 4) contains(element) - сообщает о присутствии элемента в коллекции
        // 5) set(index, new_value) - update, обновление данных по индексу
        // 6) remove(index/value) - удаление элемента по индексу/значению

2. Назовите преимущества использования коллекций.
2.1 - Повторное использование и совместимость.
    - Хорошо реализовано, требует меньше усилий (уже реализовано).

3. Какие данные могут хранить коллекции?

4. Какие есть типы коллекций? Как они характеризуются?
4.1 List - список, динамически изменяемый массив. Объекты хранятся в порядке их добавления.
4.2 Set - набор, исключает повторы (дубляжи).
4.3 Map - набор ключ-значение, еще называется словарь.
    Map является единственным интерфейсом, который не наследует интерфейс Collection,
    но является неотъемлемой частью коллекций.

5. Назовите основные реализации List, Set, Map.
5.1 Для интерфейса List: ArrayList, LinkedList.
5.2 Для интерфейса Set:  HashSet,   LinkedHashSet, TreeSet.
5.3 Для интерфейса Map:  HashMap,   LinkedHashMap, TreeMap.

6. В чём отличие ArrayList от LinkedList?

7. В чём отличие HashSet от TreeSet?

8. В чём отличие Set от Map?

9. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?

10. Чем отличается Comparable от Comparator?

11. Что такое сортировка по принципу Natural Order?

12. Что такое equals и hashCode?
// ---------- Если equals и hashCode ДО переопределения ------------------
12.1 hashcode - число, целое 10-ти значное, в java ограничен целочисленным типом int.
12.2 Если в классе не переопределен метод equals(), то его исходный код из класса Object такой:
    public boolean equals(Object obj) {
        return (this == object)
    }
    При сравнении объектов, операция ==, equals возвращает true в одном случае - когда ссылки указывают
    на один и тот же объект. В данном случае не учитывает содержимое полей.
    Метод equals класса Object сравнивает ссылки, а не содержимое объектов.

// ---------- Если equals и hashCode ПОСЛЕ переопределения ------------------
12.3 Метод equals после переопределения у класса:
     сравнение объектов после переопределения более глубокое, с учетом сравнения полей объектов и ссылок.
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        BlackBox blackBox = (BlackBox) o;
        return varA == blackBox.varA &&
                varB == blackBox.varB;
    }
12.4 Метод hashCode после переопределения у класса:
    @Override
    public int hashCode() {
        return Objects.hash(varA, varB); //генерация хэш-кода происходит с учетом полей объекта: varA, varB
    }
12.5 Соглашение между equals и hashCode:
     * Если объекты равны (т.е. equals(Object a) == true), то хэш-коды этих объектов равны,
     ** Если хэш-коды равны, то вовсе не обязательно, что объекты равны.
12.6 Для класса String оператор == сравнивает по ссылкам (адресам),
     а метод equals() по значениям элементов.

13. Какие есть способы перебора всех элементов List?
13.1 Есть 4 варианта итерации всех элементов: 2 через цикл for, 1 через Iterator, 1 через Stream.
13.2 Четвертый вариант через Stream:
        System.out.println("4 Вариант. Обход через Stream:");
        lists.stream()
                //.forEach(System.out::print);
                .forEach(c -> System.out.println(c));

14. Как реализован цикл foreach?
14.1 Первый вариант обхода списка через цикл for:
        List<Integer> lists = new ArrayList<>();
        lists.add(20);
        lists.add(19);
        lists.add(18);
        lists.add(22);

        System.out.println("1 Вариант. Обход всех элементов через цикл for:");
        for (int i = 0; i < lists.size(); i++) {
            System.out.println(lists.get(i));
        }

14.2 Второй вариант через цикл for:
        System.out.println("2.1 Вариант. Обход всех элементов через цикл for:");
        for (Object value: lists) {
           System.out.println(value);
        }
15. В чем разница между Iterator?
15.2 Третий вариант через Iterator:
        System.out.println("3.3 Вариант. Обход через ListIterator:"); //может ходить в обе стороны: hasNext, hasPrevious, next, previous
        ListIterator iterator3 = lists.listIterator();
        while (iterator3.hasNext()) {
            System.out.println(iterator3.next());
        }
15.3 Разница такая, что перебор элементов через цикл for происходит через индекс списка List,
     + косвено известен размер этого списка или он задается в цикле, получение элемента через метод get().
     А при использовании итератора Iterator перед получением элемента проверяется его наличие методом hasNext,
     а получение элемента через метод next().
15.4 При использовании цикла for НЕЛЬЗЯ добавлять/удалять элементы из списка:
    //Пример №1 - так нельзя, ошибка java.util.ConcurrentModificationException
    for (Cat cat: cats) {
        cats.add(new Cat("Сейлем Сэйберхеген"));
    }
    //Пример №2 - так нельзя, ошибка java.util.ConcurrentModificationException
    for (Cat cat: cats) {
       if (cat.name.equals("Бегемот")) {
             cats.remove(cat);
       }
    }
15.5 При проходе через итераторы, МОЖНО удалять элементы:
     Iterator<Cat> catIterator = cats.iterator();//создаем итератор
     while(catIterator.hasNext()) {//до тех пор, пока в списке есть элементы
        Cat nextCat = catIterator.next();//получаем следующий элемент
        if (nextCat.name.equals("Филипп Маркович")) {
            catIterator.remove();//удаляем кота с нужным именем
        }
     }

16. Как происходит удаление элементов из ArrayList?
16.1 Удаление элемента из списка LinkedList:
     В основе структуры ArrayList лежит динамический массив. При превышении максимального на данный момент размера происходит увеличение в 1.5 раза.
     Причем начальный размер равен 10. Как и в vector, в ArrayList не предусмотрено изменение размера при удалении элементов.
     Для принудительного изменения размера следует использовать метод trimToSize().
     При удалении элементов из ArrayList, во-первых, уничтожается сам объект. Во-вторых, каждый объект после этой точки сдвигается на один элемент.
     Как и при добавлении к концу массива, удаление из конца массива является наилучшим случаем, потому что при этом нужно перемещать ноль объектов.
     Также стоит заметить, что нам не нужно изменять размер внутреннего массива, чтобы сделать его меньше.
     Выделенное место может оставаться таким же, на случай, если мы позже будем добавлять объекты.

17. Как происходит удаление элементов из LinkedList?
17.1 Удаление элемента из списка LinkedList:
     В основе структуры LinkedList лежит двухсвязанного.
     При удалении объекта из связанного списка находится узел перед удаляемым узлом.
     Он изменяется таким образом, чтобы указывать на следующий после удалённого объекта узел.
     После этого удалённый объект можно безопасно стереть.
